// Autogenerated file

import { Inject, Service, Token } from '~/ioc'
import { IApiService } from './IApiService'
import { ApiServiceClientError } from './errors/ApiServiceClientError'
import { ApiServiceErrorsCodes } from './errors/ApiServiceErrorsCodes'
import { ApiServiceRequireError } from './errors/ApiServiceRequireError'
import { ApiServiceServerError } from './errors/ApiServiceServerError'
import { ApiServiceError } from './errors/ApiServiceError'
import { HttpServiceToken, IHttpService, IHttpRequestConfig, IHttpPromise } from '~/services/http'

<% _.forEach(spec.definitions, function (definition) { %>
  import { <%= definition.name %> } from './definitions/<%= definition.name %>'
<% }) %>
<% _.forEach(spec.params, function (param) { %>
  import { <%= param.name %> } from './params/<%= param.name %>'
<% }) %>
<% _.forEach(spec.responses, function (response) { %>
  import { <%= response.name %> } from './responses/<%= response.name %>'
<% }) %>

export const ApiServiceToken = new Token<IApiService>()

@Service(ApiServiceToken)
export class ApiService implements IApiService {
  constructor (
    @Inject(HttpServiceToken) private http: IHttpService
  ) {}

<% _.forEach(spec.operations, function (op) { %>
  <%= op.operationId %> (params<%= op.paramInterfaceName ? `: ${op.paramInterfaceName}` : '?: void | null' %>, config?: IHttpRequestConfig): IHttpPromise<<%= op.responseInterfaceName ? op.responseInterfaceName : 'void' %>> {
    <% if (op.security) { %>
      config = Object.assign({}, config, { security: true })
    <% } %>

    let path = '<%= op.path %>'
    let body
    
    const queryParams = {}
    const headers = {}
    <% if (op.hasPathParams) { %>
      const pathParams = {}
    <% } %>
    <% if (op.availableParams['formData']) { %>
      const formData = new FormData()
    <% } %>

    <% _.forEach(op.parameters, function ($_param) { %>
      <% if ($_param.required === true) { %>
        this.checkRequire(params, '<%= $_param.name %>', '<%= op.operationId %>')
      <% } %>
    <% }) %>
    
    <% _.forEach(op.parameters, function ($_param) { %>
      <% if ($_param.default) { %>
        params['<%= $_param.name %>'] = (params['<%= $_param.name %>'] === undefined) ? '<%= $_param.default %>' : params['<%= $_param.name %>']
      <% } %>

      <% if ($_param.required !== true && !$_param.default) { %>
        if (params['<%= $_param.name %>'] !== undefined) {
      <% } %>

        <% if ($_param.in === 'query') { %>
          queryParams['<%= $_param.name %>'] = params['<%= $_param.name %>']
        <% } %>

        <% if ($_param.in === 'path' && op.hasPathParams) { %>
          pathParams['<%= $_param.name %>'] = params['<%= $_param.name %>']
        <% } %>

        <% if ($_param.in === 'header') { %>
          headers['<%= $_param.name %>'] = params['<%= $_param.name %>']
        <% } %>

        <% if ($_param.in === 'body') { %>
          body = params['<%= $_param.name %>']
        <% } %>

        <% if ($_param.in === 'formData') { %>
          <% if ($_param.type === 'file') { %>
            if (params['<%= $_param.name %>'].file !== undefined) {
              formData.append('<%= $_param.name %>', params['<%= $_param.name %>'].file, params['<%= $_param.name %>'].name)
            } else {
              formData.append('<%= $_param.name %>', params['<%= $_param.name %>'])
            }
          <% } else { %>
            formData.append('<%= $_param.name %>', params['<%= $_param.name %>'])
          <% } %>
        <% } %>
      
      <% if ($_param.required !== true && !$_param.default) { %>
        }
      <% } %>
    <% }) %>

    <% if (op.hasPathParams) { %>
      path = this.applyPathParams(path, pathParams)
    <% } %>

    <% if (op.availableParams['formData']) { %>
      <% if (op.consume === 'application/x-www-form-urlencoded') { %>
        body = this.encodeFormComponents(formData)
      <% } else { %>
        body = formData
      <% } %>
    <% } %>

    return this.request(path, '<%= op.method %>', headers, queryParams, body, config)
      .catch(this.onError({
        <% _.forEach(op.responses4xx, function (resp, i) { %>
          <% const delim = (i + 1 >= op.responses4xx.length) ? '' : ',' %>
          <%= resp.status %>: { message: '<%= resp.description %>', code: '<%= _.snakeCase(resp.description).toUpperCase() %>' }<%= delim %>
        <% }) %>
      }))
  }
<% }) %>

  protected checkRequire (params: { [k: string]: any }, name: string, operationId: string): void {
    if (params[name] === undefined) {
      throw new ApiServiceRequireError('Missing required parameter ' + name + ' when calling ' + operationId + '"')
    }
  }

  protected request (url: string, method: string, headers: any, params: any, data: any, externalConfig?: IHttpRequestConfig) {
    return this.http.request(Object.assign(
      { baseURL: '<%= spec.baseUrl %>' },
      externalConfig,
      { url, method, headers, params, data }
    ))
  }

  protected onError (handlers) {
    return (e) => {
      if (e && e.response && e.response.status && e.response.status >= 400 && e.response.status < 500) {
        const errorData = handlers[e.response.status] || {}
        const message = errorData.message || 'Undefined client error'
        const code = errorData.code || 'UNDEFINED_CLIENT_ERROR'
        throw new ApiServiceClientError(message, e, ApiServiceErrorsCodes[code])
      }
      if (e && e.response && e.response.status && e.response.status >= 500) {
        throw new ApiServiceServerError('Server error', e)
      }
      if (e && e.code === 'ECONNABORTED') {
        throw new ApiServiceError('Connection aborted', e)
      }
      if (e && !e.response) {
        throw new ApiServiceError('Network error', e)
      }
      throw new ApiServiceError('Unexpected error', e)
    }
  }

  protected applyPathParams (path, pathParams) {
    for (const key of Object.keys(pathParams)) {
      path = path.replace('{'+key+'}', pathParams[key].toString())
    }
    return path
  }

  protected encodeFormComponents (formData) {
    return [...formData.entries()]
      .map((e) => encodeURIComponent(e[0]) + '=' + encodeURIComponent(e[1]))
      .join('&')
  }
}
